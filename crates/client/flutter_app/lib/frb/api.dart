// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `build_root_store_from_pem`, `read_line`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Minimal function to validate FRB wiring.
Future<String> hello() => RustLib.instance.api.crateApiHello();

/// Login to the TLS-only server and return the auth response.
///
/// - `host`: e.g., "127.0.0.1" or "localhost"
/// - `port`: e.g., `8443`
/// - `ca_pem`: contents of the server's certificate (PEM) used as a root
/// - `passphrase`, `password`: user credentials
Future<LoginResponse> loginTls({
  required String host,
  required int port,
  required String caPem,
  required String passphrase,
  required String password,
}) => RustLib.instance.api.crateApiLoginTls(
  host: host,
  port: port,
  caPem: caPem,
  passphrase: passphrase,
  password: password,
);

/// Register a new user against the TLS-only server and return the auth response.
Future<LoginResponse> registerTls({
  required String host,
  required int port,
  required String caPem,
  required String passphrase,
  required String password,
}) => RustLib.instance.api.crateApiRegisterTls(
  host: host,
  port: port,
  caPem: caPem,
  passphrase: passphrase,
  password: password,
);

/// Simple Dart-friendly login response.
class LoginResponse {
  final bool success;
  final String message;
  final PlatformInt64? userId;

  const LoginResponse({
    required this.success,
    required this.message,
    this.userId,
  });

  @override
  int get hashCode => success.hashCode ^ message.hashCode ^ userId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LoginResponse &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          message == other.message &&
          userId == other.userId;
}
